# 动态规划

> 动态规划先解决子问题，再逐步解决大问题

## 绘制网格

> 用于解决这个问题的网格是什么样的呢？要确定这一点，得回答如下问题

- 单元格中的值是什么
- 如何将这个问题划分为子问题
- 网格的坐标轴是什么

## 背包问题

> 假如你是个小偷，背着一个可装 4 磅东西的背包，你可盗窃的商品有如下 3 件， 让盗窃的商品价值最高，该选择哪些商品

- 音响， 3000 元， 4 磅
- 笔记本电脑，2000 元， 3 磅
- 吉他，1500 元，1 磅

> 解析，横坐标为 1~4 磅的背包容量

| \*            | 1       | 2       | 3       | 4                      |
| ------------- | ------- | ------- | ------- | ---------------------- |
| 音响(A)       | 0       | 0       | 0       | 3000(A)                |
| 笔记本电脑(B) | 0       | 0       | 2000(B) | 3000(A)                |
| 吉他(C)       | 1500(C) | 1500(C) | 1500(C) | 2000 + 1500= 4500(B+C) |

```JavaScript
const getMaxProfit = (costs = [3000, 2000, 1500], weights = [4, 3, 1], maxWeight = 4) => {
    const planLen = costs.length - 1
    const dp = [[]]

    for (let i = 0; i <= maxWeight; i++) {
        dp[0][i] = i < weights[0] ? 0 : costs[0]
    }

    for (let m = 0; m <= maxWeight; m++) {
        for (let n = 1; n <= planLen; n++) {
            if (!dp[n]) dp[n] = []

            if (m < weights[n]) dp[n][m] = dp[n - 1][m]
            else dp[n][m] = Math.max(dp[n - 1][m], costs[n] + dp[n - 1][m - weights[n]])

        }
    }

    return dp[planLen][maxWeight]
}

console.log(getMaxProfit())

```

## 最长公共子串

> hish 和 fish 的最长公共子串

- 如果两个字母不相同，值为 0
- 如果两个字母相同，值为左上角单元格的值 + 1

| \*  | H   | I   | S   | H   |
| --- | --- | --- | --- | --- |
| F   | 0   | 0   | 0   | 0   |
| I   | 0   | 1   | 0   | 0   |
| S   | 0   | 0   | 2   | 0   |
| H   | 0   | 0   | 0   | 3   |

## 最长公共子序列

> 不小心输入了 fosh， 那原本是想输入 fish 还是 fort？

- 如果两个字母不同，值为上方和左方邻居中较大的那个
- 如果两个字母相同，值为左上方单元格的值 + 1

| \*  | F   | O   | S   | H   |
| --- | --- | --- | --- | --- |
| F   | 1   | 1   | 1   | 1   |
| I   | 1   | 1   | 1   | 1   |
| S   | 1   | 1   | 2   | 2   |
| H   | 1   | 1   | 2   | 3   |

| \*  | F   | O   | S   | H   |
| --- | --- | --- | --- | --- |
| F   | 1   | 1   | 1   | 1   |
| O   | 1   | 2   | 2   | 2   |
| R   | 1   | 2   | 2   | 2   |
| T   | 1   | 2   | 2   | 2   |
