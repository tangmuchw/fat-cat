# RegExp
>> 正则表达式描述了一种字符串匹配的模式，可以用来**检查一个串是否含有某种子串**、将**匹配的子串替换**或者**从某个串中取出符合某个条件的子串**
- 使用规则： **匹配字符串类型 + 个数**


### 常见的正则表达式
 - matchPositiveInteger: ```/^[^0 | -]([0-9]?)+$/```
 - matchFloat: ```/^(([1-9]\d*)|0)(\.\d{0,20})?$/```

###使用正则表达式的方法
| 方法  | 描述                                                                       |
| ----- | -------------------------------------------------------------------------- |
| exec  | 一个在字符串中**执行查找**匹配RegExp方法，返回一个数组，未匹配到则返回null |
| test  | 一个在字符串中**测试是否**匹配RegExp方法，返回一个数组，未匹配到则返回null |
| match | 一个在字符串中执行查找匹配**String**方法，返回一个数组，未匹配到则返回null |

### 正则表达式中的特殊字符

| 字符   | 含义   |
| ----- | ----- |
| .      | (小数点)匹配除换行符之外的任何单个字符 |
| [xyz]  | 字符集合，匹配方括号中的任意字符 |
| [^xyz] | 反向字符集合，匹配任何没有包括方括号中的字符|
| *      | 匹配前一个表达式0次到多次(0~多) => {0,} （**这里的前一个表达式可以理解成前一个字符或者一个子正则表达式**） |
| +      | 匹配前一个表达式1次到多次(1~多) => {1,}|
| ?      | 匹配前一个表达式0次到1次(0~1) => {0,1} ，如果**紧跟在任何两次×、+、？或{}后面，将会使量词变为非贪婪的（匹配尽量少的字符）** |
| \|     | 或者 
| \\d    | 匹配数字中的一个, => [0-9]|
| \\D    | 匹配非数字中的一个, => [^0-9]|
| \\s    | 空白符 |
| \\S    | 非空白符 |
| \\w    | 非特殊字符，如_ |
| \\W    | 特殊字符，如@# |
| ^      | 取反，开始标志 |
| $      | 结束标志   |
| \b | 匹配一个单词边界，即字与空格键的位置 | 两边只要没有数字，字母，汉字，下划线，如here is a word，这句话中有好几个\b
| \B | 非单词边界 |


```JavaScript
    '2018-8-8'.replace(/\b(\w)\b/g, '0$1') // '2018-08-08'

    '20180323'.replace(/^(\d{4})(\d{2})(\d{2})$/g, '$1-$2-$3' ) // '2018-03-23'

```

## 将'get-element-by-id'转换成‘getElementById’

```JavaScript
 // 假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。
 'get-element-by-id'.replace(/\-(\w)/g, (match, p) => p.toUpperCase())

 'get-element-by-id'.replace(/\-([a-z])/g, (match, p) => p.toUpperCase())
```

## 将'getElementById'转换成'get-element-by-id'
```JavaScript
 'getElementById'.replace(/[A-Z]/g, (match, p) => '-' + match.toLowerCase())
```