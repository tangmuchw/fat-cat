# roundOff

> 摘自 [js 中对 0.1 + 0.2 的理解](https://www.jianshu.com/p/90ce596f131c)

# 概念

-   对于计算机而言，两个数字在相加时是以二进制形式来进行的，在呈现结果时才转换成十进制
-   JS 中的数字使用 **IEEE 754** 双精度 64 位浮点数来存储的，它由 64 位组成，这 64 位由 3 部分组成，（S：符号位，Exponent:指数域，Fraction：尾数域）
    -   1 符号位，0 表示正数，1 表示负数 => s
    -   11 指数位 => e
    -   52 尾数位，小数部分（即有效数字）

# 十进制小数转换为二进制小数

-   用 2 乘十进制小数， 可以得到积
-   将积的整数部分取出，再用 2 乘余下的小数部分，又得到一个积
-   再将积的整数部分取出，如此进行，直到积中的小数部分为零，此时 0 或 1 为二进制的最后一位。或者达到所要求的精度为止。

# 解析

```JavaScript
0.1.toString(2) // "0.0001100110011001100110011001100110011001100110011001101"

0.2.toString(2) // 0.001100110011001100110011001100110011001100110011001101

0.1 + 0.2 = 0.30000000000000004

```

# 一个简单的解决思路

> 在知道小数位个数的前提下，可以考虑通过将浮点数放大倍数到整型(最后再除以相应倍数)，再进行运算操作，这样就能得到正确的结果了

```JavaScript
  Math.formatFloat = function (f, digit) {
      // Math.pow(指数，幂指数)
      var m = Math.pow(10, digit);
      // Math.round（） 四舍五入
      return Math.round(f * m, 10) / m;
    }
    console.log(9.12 * 100);  // 911.9999999999999
    console.log(Math.formatFloat(9.12 * 100, 2));  // 9.12

```

# 总结

> 可以看到，当十进制小数的二进制表示的有限数字超过 52 位时，在 JS 里是不能**精确存储**的，这时候就存在**舍入误差**(Round-off error)
