# roundOff

> 摘自 [js 中对 0.1 + 0.2 的理解](https://www.jianshu.com/p/90ce596f131c)

# 概念

- 对于计算机而言，两个数字在相加时是以二进制形式来进行的，在呈现结果时才转换成十进制
- JS 中的数字使用 **IEEE 754** 双精度 64 位浮点数来存储的，它由 64 位组成，这 64 位由 3 部分组成，（S：符号位，Exponent:指数域，Fraction：尾数域）
  - 1 符号位，0 表示正数，1 表示负数 => s
  - 11 指数位 => e
  - 52 尾数位，小数部分（即有效数字）

# 十进制小数转换为二进制小数

- 用 2 乘十进制小数， 可以得到积
- 将积的整数部分取出，再用 2 乘余下的小数部分，又得到一个积
- 再将积的整数部分取出，如此进行，直到积中的小数部分为零，此时 0 或 1 为二进制的最后一位。或者达到所要求的精度为止。

# 解析

```JavaScript
0.1.toString(2) // "0.0001100110011001100110011001100110011001100110011001101"

0.2.toString(2) // 0.001100110011001100110011001100110011001100110011001101

0.1 + 0.2 = 0.30000000000000004

```

# 总结

> 可以看到，当十进制小数的二进制表示的有限数字超过 52 位时，在 JS 里是不能**精确存储**的，这时候就存在**舍入误差**(Round-off error)
