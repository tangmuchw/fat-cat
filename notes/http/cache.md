# HTTP 缓存

> HTTP 缓存分为强缓存和协商缓存

[TOC]

## 强缓存

| header 属性             | 可选值                                                                                                                                                                                                                                                   | 优先级 | 优选点                                                                                                               |
| ----------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------ | -------------------------------------------------------------------------------------------------------------------- |
| Pragma(HTTP/1.0)        | no-cache: 不直接使用缓存，根据新鲜度来使用缓存                                                                                                                                                                                                           | 高     | 1.响应头不支持这个属性 <br/> 2.为了兼容 HTTP/1.0 的客户端 <br/> 3.在 HTTP 1.1 中已被废弃                             |
| Cache-Control(HTTP/1.1) | 1.no-cache: 不直接使用缓存，根据新鲜度来使用缓存 <br /> 2.no-store: 不使用缓存，每次都是请求下载新资源 <br /> 3.max-age: xx 秒， 缓存时长 <br /> 4.public/private: 是否只能被单个用户使用，默认为 private <br /> 5.must-revalidate: 每次访问需要缓存校验 | 中     | 1.请求头和响应头都支持这个属性 <br/> 2.不适用于 HTTP/1.0 <br/> 3.在缓存未失效前，获取不到修改后的资源                |
| Expires(HTTP/1.0+)      | GMT 时间（ Sat, 19 May 2018 17:17:24 GMT）                                                                                                                                                                                                               | 低     | 1.服务器和客户端的时间不一致会出问题 <br/> 2.适用于 HTTP/1.0 和 HTTP1.1 <br/> 3.在缓存未失效前，获取不到修改后的资源 |

> 缓存校验有：Expires，Last-Modified，E-Tag

> 在 chrome 浏览器中返回的 200 状态会有两种状态：

- from memory cache (从内存中获取/一般缓存封信频率较高的 js、图片和字体等资源)
- from disk cache (从字盘中获取/一般缓存更新频率较低的 js 和 css 等资源)

## 协商缓存

> 当第一次请求时，服务器返回的响应头中没有 Cache-Control 和 Expires 或者 Cache-Control 和 Expires 过期，再或者不走强缓存，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。

- 如果服务器端的资源没有修改，那么就会返回 304 状态码，告诉浏览器可以使用缓存中的数据，这样可以减少服务器的数据传输压力
- 如果数据有更新就会返回 200 状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。

> 跟协商缓存相关的 header 头属性有 ETag/If-None-Match、Last-Modified/If-Modified-Since 响应头和请求头需要成对出现

| header 属性                     | 可选值                     | 优先级 | 优选点                                                                                                                                                               |
| ------------------------------- | -------------------------- | ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ETag/If-Not-Match               | 校验值(一般为一个 hash 值) | 高     | 1.默认使用 hash 算法，在分布式环境中可能出现不同服务器生成的 ETag 值不一致 <br /> 2.计算 ETag 需要性能消耗 <br /> 3.精确的判断资源有无被修改，可识别一秒内的修改次数 |
| Last-Modified/If-Modified-Since | GMT 时间                   | 低     | 1.只要资源修改，无论内容有无变化，都会将资源返回客户端 <br /> 2.以时刻为标识，无法获取一秒内的修改变化 <br /> 3.某些服务器不能准确获取最后的修改时间                 |

## 使用 HTTP 缓存的好处

- 减少了冗余的数据传输，节省了网费
- 缓解服务器的压力，大大提高了网站的性能
- 加快了客户端加载网页的速度

## HTTP 缓存的注意点

- 强缓存情况下，只要缓存还没过期，就会直接从缓存中取数据，就算服务器有数据变化，也不会从服务器端获取，这样就无法获取到修改后的数据。解决的方法**修改资源的 url**

- 尽量减少 304 的请求，协商缓存每次都会与后台服务器进行交互，因此性能不是很好

- 在 Firefox 浏览器下，使用 Cache-Control: no-cache 是不生效的，其识别的是 no-store，因此一般使用 Cache-Control: no-cache, no-store

- 与缓存相关的 header 属性： Vary、Date/Age

  - Vary: 表示服务端会以什么基准字段来区分、筛选缓存版本

    - 举例： Vary: User-Agent; 其知会代理服务器需要以 User-Agent 这个请求首部字段来区别缓存版本，防止传递给客户端的缓存不正确

  - Date/Age: 响应报文中的 Date 和 Age 字段，区分其收到的资源是否命中了代理服务器的缓存
